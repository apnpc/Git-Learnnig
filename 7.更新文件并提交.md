## 实验

在 test.txt  文件中添加一行内容 abc，提交至版本库

```powershell
# 查看仓库状态
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   test.txt
# 暂存文件
$ git add test.txt

# 提交更改
$ git commit -m "Added abc to the test.txt"
[master d7f681f] Added abc to the test.txt
 1 file changed, 1 insertion(+)
```

## `git add`重复操作？

test.txt 文件已经被追踪了，为什么修改之后还需要使用`git add`重复操作？

如果我们使用像 SVN 或 CVS 这样的基于文件的源代码管理系统，只需保存文件即可，系统会自动检测到更改。但是 Git 不是这样运行的，我们需要明确的告知 Git，我们要提交这些变化，它才会帮我们保存更改，即，通过 `git commit` 命令来完成提交。这将在 Git 历史记录中创建一个新的提交。

在上述实验中，我们强调了 Git 跟踪的是代码库中的变更，而不是单个文件的变更。这点不同于传统基于文件的版本控制系统。

具体来说，在实验中，我们使用 `git add` 命令告诉 Git 开始跟踪一个新的文件，并记录其当前状态。然后我们对该文件进行修改并提交更改，这将创建一个新的 Git 提交记录。这个提交会让 Git 检测所有文件的变化，并记录这些变化 ，这样，Git 能够跟踪整个代码库的演变历史，而不是仅仅跟踪单个文件的更改历史。

相比之下，传统基于文件的版本控制系统会跟踪每个文件的变化历史，而无法提供像分支和合并这样的高级功能。Git 正是因为能够处理整个代码库的变更历史，才能够提供这些强大的功能。因此，Git 是一种更加先进和灵活的版本控制系统，它不是基于文件的版本控制系统。

## 跳过使用暂存区域

每次都需要执行暂存命令，有点繁琐，如果你希望跳过暂存区，直接将更改提交到版本库中，则可以使用以下命令：
```bash
$ git commit -a -m "Commit message"
```
`
在这个命令中，`-a` 选项参数表示自动将所有已修改的文件添加到暂存区中，并将其提交到版本控制系统中。这样就可以跳过将更改显式添加到暂存区的步骤，直接将所有更改一次性提交。

需要注意的是，在使用该命令时，只会将已修改的文件提交到版本控制系统中，而对于新添加的文件则不会生效。如果您要将新添加的文件也提交到版本控制系统中，则需要手动将其添加到暂存区（使用 `git add` 命令）或者使用 `-a` 选项参数的组合命令 `git commit -am "Commit message"`，它相当于执行了 `git add .` 和 `git commit` 两个命令。

尽管跳过暂存区可能会使提交更加方便快捷，但建议在进行提交前仔细检查所做的更改并确保代码能够正常运行。 这样可以避免不必要的错误和引入不良代码。

